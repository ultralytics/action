# Ultralytics Actions 🚀, AGPL-3.0 License https://ultralytics.com/license
#
# Example usage:
#
# Basic usage (will retry failed step 3 times):
# steps:
#   - uses: ultralytics/actions/retry@main
#     with:
#       run: python train.py
#
# Advanced usage:
# steps:
#   - uses: ultralytics/actions/retry@main
#     with:
#       run: |
#         python setup.py install
#         pytest tests/
#       retries: 2             # Retry twice after initial attempt (3 total runs)
#       timeout_minutes: 30    # Each attempt times out after 30 minutes
#       retry_delay_seconds: 60 # Wait 60 seconds between retries
#       shell: bash            # Use python or bash shell

name: "Step-Level Retry"
description: "Retries a step while preserving its full context"
inputs:
  timeout_minutes:
    description: "Maximum time in minutes for each attempt"
    required: false
    default: "60"
  retries:
    description: "Number of retry attempts after initial run"
    required: false
    default: "3"
  retry_delay_seconds:
    description: "Delay between retries in seconds"
    required: false
    default: "30"
  run:
    description: "Command to run"
    required: true
  shell:
    description: "Shell to use (bash or python)"
    required: false
    default: "bash"

runs:
  using: "composite"
  steps:
    - name: Execute with retry (Python)
      if: inputs.shell == 'python'
      shell: python
      env: ${{ env }}
      run: |
        import time
        import os
        import tempfile

        def write_summary(msg, is_error=False):
            with open(os.environ['GITHUB_STEP_SUMMARY'], 'a') as f:
                f.write(f"\n\n{'### ❌ Error' if is_error else ''}\n{msg}")

        with tempfile.NamedTemporaryFile(mode='w+') as env_file:
            start = time.time()
            for attempt in range(${{ inputs.retries }} + 1):
                if attempt > 0:
                    print(f"::group::Retry {attempt} of ${{ inputs.retries }}")

                if time.time() - start > ${{ inputs.timeout_minutes }} * 60:
                    write_summary(f"Step timed out after ${{ inputs.timeout_minutes }} minutes", True)
                    exit(1)

                try:
                    exec(f"""
def set_env(name, value):
    with open('{env_file.name}', 'a') as f:
        f.write(f'::set-env name={{name}}::{value}\\n')
{${{ inputs.run }}}
                    """)
                    print(env_file.read())
                    exit(0)
                except Exception as e:
                    msg = f"{'Retry' if attempt > 0 else 'Initial attempt'} failed: {str(e)}"
                    print(msg)
                    if attempt > 0:
                        print("::endgroup::")
                    
                    if attempt == ${{ inputs.retries }}:
                        write_summary(f"Final error after {attempt + 1} attempts: {str(e)}", True)
                        exit(1)
                    
                    print(f"Retrying in ${{ inputs.retry_delay_seconds }} seconds...")
                    time.sleep(${{ inputs.retry_delay_seconds }})

    - name: Execute with retry (Bash)
      if: inputs.shell != 'python'
      shell: bash
      env: ${{ env }}
      run: |
        write_summary() {
            if [ "$2" = "error" ]; then
                echo -e "\n\n### ❌ Error\n$1" >> $GITHUB_STEP_SUMMARY
            else
                echo -e "\n$1" >> $GITHUB_STEP_SUMMARY
            fi
        }

        retry_command() {
            local start=$(date +%s)
            local env_file=$(mktemp)
            
            for ((attempt=0; attempt <= ${{ inputs.retries }}; attempt++)); do
                [ $attempt -gt 0 ] && echo "::group::Retry $attempt of ${{ inputs.retries }}"
                
                if [ $(($(date +%s) - start)) -gt $((${{ inputs.timeout_minutes }} * 60)) ]; then
                    write_summary "Step timed out after ${{ inputs.timeout_minutes }} minutes" error
                    return 1
                fi
                
                # Run command and capture output
                output=$(set -o pipefail; {
                    eval "$(echo '${{ inputs.run }}' | sed 's/>>.*GITHUB_ENV/>>'$env_file'/g')"
                } 2>&1)
                exit_code=$?
                
                # Always write output to summary
                write_summary "$output"
                
                if [ $exit_code -eq 0 ]; then
                    [ -f "$env_file" ] && cat "$env_file" | grep "^[^<].*=.*" | while read line; do
                        echo "::set-env name=${line%%=*}::${line#*=}"
                    done
                    [ $attempt -gt 0 ] && echo "::endgroup::"
                    rm "$env_file"
                    return 0
                fi
                
                if [ $attempt -eq ${{ inputs.retries }} ]; then
                    write_summary "Final error after $((attempt + 1)) attempts:\n\`\`\`\n$output\n\`\`\`" error
                    rm "$env_file"
                    return $exit_code
                fi
                
                echo "Retrying in ${{ inputs.retry_delay_seconds }} seconds..."
                sleep ${{ inputs.retry_delay_seconds }}
            done
        }
        retry_command
